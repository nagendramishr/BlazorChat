# BlazorChat Implementation Tasks

## Current State Analysis
âœ“ .NET 10 Blazor web server with Kestrel configured
âœ“ ASP.NET Core Identity with Individual authentication
âœ“ Entity Framework Core with SQLite database
âœ“ Basic authentication components (Account pages)
âœ“ Dependency injection configured
âœ“ Basic Blazor components structure (Layout, Pages)

================================================================================
## PHASE A: Architecture Improvements (Priority - Do Before New Features)
================================================================================
NOTE: These architectural improvements should be implemented BEFORE continuing with 
Phase 4 incomplete tasks (C4.3.5, C4.4) to ensure clean, scalable implementation.

### SimpleL7Proxy Integration (Assumed Backend)
BlazorChat will use Microsoft's SimpleL7Proxy (https://github.com/microsoft/SimpleL7Proxy)
as the AI gateway. This OSS project provides significant infrastructure benefits:

**What SimpleL7Proxy Provides Out-of-Box**:
- âœ… Token extraction from SSE streams (Prompt_Tokens, Completion_Tokens, Total_Tokens)
- âœ… Application Insights integration with custom dimensions
- âœ… Event Hub streaming for high-volume telemetry
- âœ… Distributed request correlation (MID, ParentId, OperationId)
- âœ… Circuit breaker pattern for backend resilience
- âœ… Multi-backend load balancing and failover
- âœ… Priority queues for user tiering (Gold/Silver)
- âœ… Retry logic with exponential backoff
- âœ… Health check endpoints

**Impact on BlazorChat Tasks**:
- C4.4 (Usage Tracking): SIMPLIFIED - Query App Insights instead of building token extraction
- A2 (MediatR Events): OPTIONAL - Proxy handles telemetry, use events only for app-level concerns
- E2.1 (Distributed Tracing): COVERED - Built-in request correlation
- E3.1 (Quota Management): EASIER - Proxy has priority queues
- E7.4 (Graceful Degradation): SIMPLIFIED - Circuit breaker built-in

### Task A0: SimpleL7Proxy Integration âœ… COMPLETE
Priority: HIGH (Foundation - enables simplified token tracking)
Goal: Route all AI traffic through SimpleL7Proxy gateway via configuration.

**Implementation Summary** (Completed Jan 2026):
- âœ… Added `AIFoundry:ProxyEndpoint` config option in appsettings.json
- âœ… Updated AIFoundryService to use either Endpoint or ProxyEndpoint
- âœ… Error if both are configured (must choose one)
- âœ… Error if neither is configured
- âœ… Logs which endpoint mode is being used (direct vs proxy)

**Usage**:
- For direct connection: Set `AIFoundry:Endpoint`, leave `ProxyEndpoint` empty
- For proxy routing: Set `AIFoundry:ProxyEndpoint`, leave `Endpoint` empty
- Proxy is transparent - no code changes needed for streaming

**Deployment Note**: SimpleL7Proxy deployment/configuration is handled separately.
See: https://github.com/microsoft/SimpleL7Proxy for deployment instructions.

### Current Architecture Issues Identified:
- **Fat Component**: Chat.razor has 500+ lines, handles UI + business logic + coordination
- **No Domain Layer**: Business rules scattered across services and components  
- **Tight Coupling**: Components directly depend on infrastructure services
- **No Event System**: Cross-cutting concerns require manual calls everywhere
- **Stateful Singletons**: AIFoundryService holds in-memory state, doesn't scale
- **No Background Jobs**: Everything is request/response, no async processing

### Task A1: Application Service Layer âœ… COMPLETE
Priority: HIGH (Foundation for all future features)
Goal: Create single entry point for chat operations, extract business logic from Chat.razor.

**Current Problem**:
```
Chat.razor â†’ CosmosDbService, AIFoundryService, TelemetryService, 
             OrganizationService, ContextManager (5+ direct dependencies)
```

**Target Architecture**:
```
Chat.razor â†’ IChatApplicationService â†’ Domain Services â†’ Infrastructure
                                    â†³ Raises Domain Events
```

#### A1.1: Create Chat Application Service âœ…
- [x] Create interface: src/Services/Application/IChatApplicationService.cs
  ```csharp
  public interface IChatApplicationService
  {
      Task<Conversation> CreateConversationAsync(string userId, string orgId, string? title = null);
      Task<Conversation?> GetConversationAsync(string conversationId, string userId);
      Task<IEnumerable<Conversation>> GetUserConversationsAsync(string userId);
      Task<IEnumerable<Message>> GetMessagesAsync(string conversationId, string userId);
      IAsyncEnumerable<ChatResponseChunk> SendMessageStreamingAsync(string conversationId, string userId, string message, CancellationToken ct);
      Task<bool> DeleteConversationAsync(string conversationId, string userId);
      Task<bool> ResumeConversationAsync(string conversationId, string userId); // Thread rehydration
  }
  ```
- [x] Create implementation: src/Services/Application/ChatApplicationService.cs
- [x] Encapsulate: authorization checks, validation, Cosmos DB calls, AI calls, telemetry
- [x] Register as scoped service in Program.cs

#### A1.2: Refactor Chat.razor to Use Application Service âœ…
- [x] Replace 5+ service injections with single IChatApplicationService (reduced to 2: ChatService + OrganizationService)
- [x] Move all business logic out of Chat.razor
- [x] Keep Chat.razor focused on: UI rendering, user input handling, state display
- [x] Reduced Chat.razor from ~585 lines to ~502 lines (UI-only code)

#### A1.3: Create Organization Application Service âœ… COMPLETE
**Implementation Summary** (Completed Jan 2026):
- [x] Created interface: src/Services/Application/IOrganizationApplicationService.cs
- [x] Created implementation: src/Services/Application/OrganizationApplicationService.cs
- [x] Created OrganizationEvents.cs with defined event types
- [x] Updated OrganizationController to use application service
- [x] Registered service in Program.cs

**Features Implemented**:
- Validation: Name (2-100 chars), Slug (3-50 chars, lowercase, no reserved words), AI config URL validation
- Event Publishing: OrganizationCreated, OrganizationUpdated, OrganizationDisabled, OrganizationEnabled, OrganizationSlugChanged, OrganizationAIConfigChanged
- Request/Response models: CreateOrganizationRequest, UpdateOrganizationRequest, OrganizationResult
- Tracks which fields changed on updates for granular events

**Architecture**:
```
OrganizationController â†’ IOrganizationApplicationService â†’ IOrganizationAdminService â†’ CosmosDB
                              â†“
                         IEventClient (Event Hub)
```

**Note**: IOrganizationService remains separate for read-only current org context in UI components.

### Task A2: Event Publishing to Event Hub âœ… COMPLETE (Replaces MediatR)
Priority: MEDIUM
Goal: Publish chat events to Azure Event Hub for consumption by Reporting Service.

**Decision**: Use Azure Event Hub instead of MediatR.
- MediatR = in-process pub/sub (same app)
- Event Hub = distributed pub/sub (across services)

Since BlazorChat has a separate Reporting Service (see reporting-tasks.txt),
Event Hub is the right choice for cross-service event distribution.

**Implementation Summary** (Completed Jan 2026):
- âœ… Created Services/EventHub/ folder (adapted from SimpleL7Proxy)
- âœ… EventHubConfig.cs - Minimal config matching SimpleL7Proxy
- âœ… EventHubClient.cs - Buffered async sender with background writer
- âœ… IEventClient.cs - Interface matching SimpleL7Proxy pattern
- âœ… NullEventClient.cs - No-op when Event Hub not configured
- âœ… ChatEvents.cs - BlazorChat-specific event types
- âœ… Auto-detection: Uses NullEventClient if no connection configured
- âœ… Supports both connection string and managed identity auth

**Configuration** (appsettings.json):
```json
"EventHub": {
  "ConnectionString": "",        // Use this OR EventHubNamespace
  "EventHubNamespace": "",       // Uses DefaultAzureCredential
  "EventHubName": "chat-events",
  "StartupSeconds": 10
}
```

**Event Types Available**:
- MessageSentEvent - User sends message to AI
- MessageReceivedEvent - AI response received
- ConversationCreatedEvent - New conversation started
- ConversationDeletedEvent - Conversation deleted
- ThreadResumedEvent - AI thread rehydration
- QuotaExceededEvent - User hit quota limit
- ChatErrorEvent - Error during chat processing

**Usage in Services**:
```csharp
_eventClient.SendData(new MessageSentEvent {
    OrganizationId = orgId,
    UserId = userId,
    ConversationId = conversationId,
    InputCharacters = message.Length
});
```

**Next Step**: Wire up event publishing in ChatApplicationService.

### Task A3: Thread State Persistence âœ… COMPLETE
Priority: HIGH (Solves thread persistence across restarts)
Goal: Persist thread state to Cosmos DB instead of in-memory dictionaries.

**Implementation Status** (Completed Jan 2026):
- âœ… Created IThreadStateService interface (src/Services/Cache/IThreadStateService.cs)
- âœ… Created InMemoryThreadStateService (default for dev)
- âœ… Created CosmosDbThreadStateService (production)
- âœ… Added ThreadState:Provider config in appsettings.json
- âœ… Integrated into ChatApplicationService

**Architecture Decision** (Jan 2026):
Redis was evaluated and deemed unnecessary. Rationale:
- Cosmos DB provides acceptable latency (~5-10ms) for thread lookups
- SimpleL7Proxy already handles rate limiting and circuit breakers
- Single-instance deployment doesn't require distributed cache
- Reduces infrastructure complexity and cost

**Current Architecture**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ BlazorChat  â”‚â”€â”€â”€â”€â–¶â”‚ Cosmos DB   â”‚  (Thread state + all persistent data)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SimpleL7Proxy   â”‚  (Rate limiting, circuit breakers, throttling)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

================================================================================

**Note**: Rate limiting is handled by SimpleL7Proxy (priority queues, throttling).
No additional rate limiting infrastructure needed in BlazorChat.

### Task A4: Background Job Infrastructure - REMOVED FROM SCOPE
**Decision** (Jan 2026): Background jobs do not belong in the chat app.
Any scheduled tasks (usage aggregation, cleanup, webhooks) belong in:
- Reporting Service (see reporting-tasks.txt)
- Separate Azure Functions worker
- Dedicated background worker service

BlazorChat is a UI/API application, not a job runner.

### Task A5: Repository Pattern Refactoring - DEFERRED
Priority: LOW (Optional - only if unit testing requires it)
**Decision** (Jan 2026): Current CosmosDbService is sufficient.
Repository pattern adds abstraction without immediate benefit.
Defer until unit testing requirements mandate mock repositories.

================================================================================
## PHASE A: COMPLETE âœ…
================================================================================

**Summary** (Jan 2026):
- A0: SimpleL7Proxy Integration âœ…
- A1: Application Service Layer âœ… (Chat + Organization)
- A2: Event Hub Publishing âœ…
- A3: Thread State Persistence âœ… (Cosmos DB, no Redis)
- A4: Background Jobs - OUT OF SCOPE (separate service)
- A5: Repository Pattern - DEFERRED (not needed yet)

**Architecture Achieved**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        BlazorChat                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚  â”‚ Chat.razor  â”‚â”€â”€â”€â–¶â”‚ IChatApplicationSvc  â”‚                    â”‚
â”‚  â”‚ (UI only)   â”‚    â”‚ IOrganizationAppSvc  â”‚                    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚                                â”‚                                 â”‚
â”‚          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚          â–¼                     â–¼                     â–¼          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ CosmosDbSvc   â”‚    â”‚ AIFoundrySvc  â”‚    â”‚ IEventClient   â”‚   â”‚
â”‚  â”‚ (persistence) â”‚    â”‚ (AI calls)    â”‚    â”‚ (Event Hub)    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                      â”‚                      â”‚
         â–¼                      â–¼                      â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚CosmosDB â”‚          â”‚SimpleL7Proxyâ”‚        â”‚ Event Hub â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚                      â”‚
                               â–¼                      â–¼
                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                         â”‚Azure AI â”‚          â”‚Reporting Svcâ”‚
                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

================================================================================
## PHASE 1: Data Layer Migration (Cosmos DB)

### Task C1.1: Install Cosmos DB Dependencies âœ“
- [x] Add NuGet package: Microsoft.Azure.Cosmos (latest)
- [x] Add NuGet package: Azure.Identity (for DefaultAzureCredential)
- [ ] Remove/phase out: Microsoft.EntityFrameworkCore.Sqlite
- [x] Update src.csproj file

### Task C1.2: Create Cosmos DB Models and Schema âœ“
- [x] Create folder: src/Models
- [x] Create model: src/Models/Conversation.cs
  - Properties: Id, UserId, Title, CreatedAt, UpdatedAt, PartitionKey (UserId)
- [x] Create model: src/Models/Message.cs
  - Properties: Id, ConversationId, UserId, Content, Role (User/Assistant), Timestamp, Metadata
- [x] Create model: src/Models/UserPreferences.cs
  - Properties: UserId, Theme, NotificationSettings, etc.

### Task C1.3: Create Cosmos DB Service Layer âœ“
- [x] Create interface: src/Services/ICosmosDbService.cs
- [x] Create service: src/Services/CosmosDbService.cs
  - Implement singleton pattern with CosmosClient
  - Use DefaultAzureCredential for authentication
  - Implement methods: GetConversationsAsync, GetMessagesAsync, SaveMessageAsync, etc.
  - Enable diagnostic logging
- [x] Create folder: src/Services
- [x] Register service as singleton in Program.cs

### Task C1.4: Update Configuration (Partial) âš¡
- [x] Add Cosmos DB settings to appsettings.json:
  - CosmosDb:Endpoint
  - CosmosDb:DatabaseName
  - CosmosDb:ConversationsContainerName
  - CosmosDb:PreferencesContainerName
- [x] Add environment-specific configs in appsettings.Development.json
- [ ] Remove SQLite connection string

### Task C1.5: Create Cosmos DB Repository Pattern
- [x] ALTERNATIVE: Integrated CosmosDbService directly into Chat UI (simpler approach)
- [x] Implemented conversation loading from Cosmos DB
- [x] Implemented message loading with proper partition keys
- [x] Implemented conversation creation and persistence
- [x] Implemented message persistence (user and assistant)
- [x] Added error handling and user notifications
- [x] Added conversation auto-titling from first message
NOTE: Skipped separate repository layer - using service directly is sufficient for this app

## PHASE 2: Security Updates
NOTE: Current ASP.NET Core Identity with SQLite is sufficient for demo. Azure AD migration is planned for post-demo (see Phase 10).

### Task C2.1: Implement Authorization Policies (Current Identity) âœ“
- [x] Create policy: UserCanAccessOwnConversations
- [x] Create authorization handler: src/Authorization/ConversationAuthorizationHandler.cs
- [x] Register policies in Program.cs
- [x] Apply [Authorize] attributes to endpoints/components

### Task C2.2: Configure CORS âœ“
- [x] Add CORS policy in Program.cs (AllowConfiguredOrigins policy)
- [x] Configure allowed origins in appsettings.json (Cors:AllowedOrigins array)
- [x] Apply CORS middleware (UseCors)

### Task C2.3: Implement Rate Limiting âœ“
- [x] Add NuGet package: Microsoft.AspNetCore.RateLimiting (built-in to ASP.NET Core)
- [x] Configure rate limiting policies in Program.cs (GlobalLimit: 100/min, AILimit: 20/min)
- [x] Apply rate limiting middleware (UseRateLimiter)
- [x] Configure limits in appsettings.json (RateLimiting section)

### Task C2.4: Add Azure Key Vault Integration âœ“
- [x] Add NuGet package: Azure.Extensions.AspNetCore.Configuration.Secrets
- [x] Add NuGet package: Azure.Security.KeyVault.Secrets
- [x] Update Program.cs to add Key Vault configuration provider
- [x] Configure Key Vault URL in appsettings.json
- [x] Move sensitive settings (AI Foundry keys) to Key Vault (optional configuration)

### Task C2.5: Input Validation & Sanitization âœ“
- [x] Add NuGet package: System.ComponentModel.Annotations (built-in)
- [x] Create validation models: src/Models/ValidationModels.cs
  - ChatMessageInput, ConversationInput, OrganizationInput
- [x] Implement message sanitization service: src/Services/MessageSanitizationService.cs
  - SanitizeMessage, SanitizeSlug, SanitizeCss, ContainsPromptInjection
- [x] Add validation attributes to input models
- [x] Register sanitization service in Program.cs (singleton)

## PHASE 2.5: Multi-Organization Architecture (New)
Goal: Support multiple organizations with isolated configuration and branding sharing the same db instance.

### Task C2.5.1: Multi-Organization Database Schema âœ“
- [x] Create model: src/Models/Organization.cs
  - Properties: Id, Name, Slug (Index), PublicThemeSettings, PrivateAIConfig
  - Look & Feel: CustomCss (string), HeaderHtml (string), FooterHtml (string)
  - NOTE: Split model into "OrganizationPublicDTO" (Theme/Branding) for UI and "OrganizationSecrets" for Server to prevent leaking AI keys via public URL probing.
- [x] Update model: src/Data/ApplicationUser.cs
  - Add property: OrganizationId

### Task C2.5.2: Organization Resolution Strategy âœ“
- [x] Implement Organization Service: src/Services/OrganizationService.cs
- [x] Update routing to support `/org/{slug}/...`
- [x] Create Organization Resolver Component: src/Components/Shared/OrganizationResolver.razor
- [x] Validate Slug Uniqueness on creation.

### Task C2.5.3: Organization Management API Service (New) âœ“
- [x] Create interface: src/Services/IOrganizationAdminService.cs
- [x] Implement service: src/Services/OrganizationAdminService.cs
  - Methods: CreateOrganizationAsync, UpdateOrganizationAsync, DisableOrganizationAsync, ListOrganizationsAsync
- [x] Create API Endpoints or Admin Page to manage organizations.
  - Implemented `src/Controllers/OrganizationController.cs`
- [ ] Create Admin Policy: Require "GlobalAdmin" role.
- [ ] Create Admin UI Pages (optional for now, API first).

### Task C2.5.4: Infrastructure Automation âœ“
- [x] Create Azure CLI setup script: scripts/init-azure-resources.ps1 (and .sh)
- [x] Verify script creates all containers including `organizations`.
- [x] Update CosmosDbService to manage Organizations container logic.

### Task C2.5.5: UI Configuration Updates âœ“
- [x] Update MainLayout to support dynamic branding colors (MudBlazor).
- [x] Add Organization Awareness to NavMenu.
- [x] Fix MudBlazor provider duplication issues in interactive rendering.
- [ ] Create page: src/Components/Pages/Admin/OrganizationList.razor
- [ ] Implement basic CRUD for Organizations

## PHASE 3: Application Insights & Monitoring

### Task C3.1: Add Application Insights âœ“
- [x] Add NuGet package: Microsoft.ApplicationInsights.AspNetCore
- [x] Add Application Insights to Program.cs
- [x] Configure instrumentation key in appsettings.json
- [x] Enable connection string in appsettings (use Key Vault)

### Task C3.2: Add Custom Telemetry âœ“
- [x] Create service: src/Services/TelemetryService.cs
- [x] Add custom events: MessageSent, MessageReceived, AIResponseTime
- [x] Add custom metrics: ConversationLength, TokenUsage, ResponseLatency
- [x] Track exceptions with custom properties
- [x] Register service in Program.cs

### Task C3.3: Add Health Checks âœ“
- [x] Add NuGet package: Microsoft.Extensions.Diagnostics.HealthChecks (built-in to ASP.NET Core)
- [x] Create health check: src/HealthChecks/CosmosDbHealthCheck.cs
- [x] Create health check: src/HealthChecks/AIFoundryHealthCheck.cs
- [x] Add health check endpoints in Program.cs:
  - /liveness (basic app alive check)
  - /startup (dependencies initialized check)
  - /readiness (ready to accept traffic check)
- [ ] Configure health check UI (optional)

### Task C3.4: Cosmos DB Diagnostic Logging âœ“
- [x] Enable Cosmos DB diagnostics in CosmosDbService
- [x] Log diagnostic strings for slow queries (> threshold)
- [x] Log diagnostic strings on errors
- [ ] Add custom log filtering in appsettings.json

## PHASE 4: AI Foundry Integration

### Task C4.1: Add AI Foundry SDK âœ“
- [x] Add NuGet package: Azure.AI.Projects
- [x] Add NuGet package: Microsoft.Agents.AI.AzureAI
- [x] Add configuration in appsettings.json:
  - AIFoundry:Endpoint
  - AIFoundry:ModelDeployment
  - AIFoundry:AgentName
  - AIFoundry:AgentInstructions
- [ ] Store API keys in Key Vault (user will provide endpoint details)

### Task C4.2: Create AI Service Layer âœ“
- [x] Create interface: src/Services/IAIFoundryService.cs
- [x] Create service: src/Services/AIFoundryService.cs
  - Implement agent communication with Microsoft Agent Framework
  - Implement streaming response support
  - Implement error handling and thread management
  - Implement conversation context via AgentThread
  - Use DefaultAzureCredential
- [x] Register service in Program.cs
- [x] Integrate with Chat.razor for streaming responses

### Task C4.5: Multi-Organization AI Configuration (New) âœ“
- [x] Create AIFoundryServiceFactory: src/Services/AIFoundryServiceFactory.cs
  - Factory pattern for creating org-specific AI service instances
  - OrganizationAIConfiguration wrapper for dynamic config
- [x] Implement dynamic agent configuration resolution based on current Organization
- [x] AIFoundryService accepts IConfiguration (works with org-specific config)
- [x] Register AIFoundryServiceFactory in Program.cs
- [ ] Test with multiple agent endpoints

### Task C4.3: Create Conversation Context Manager âœ“
- [x] Create service: src/Services/ConversationContextManager.cs
- [x] Implement token counting
- [x] Implement context trimming strategy
- [x] Implement conversation summarization stub
- [x] Register service in Program.cs
- [x] Integrate into Chat.razor for token limit checking

### Task C4.3.5: Thread Persistence & Rehydration on Conversation Resume âœ… COMPLETE
Goal: Restore AI agent context when user resumes a previous conversation without double-billing tokens.

**Implementation Summary** (Completed Jan 2026):
- âœ… Added `AgentThreadId`, `AgentThreadCreatedAt`, `AgentThreadExpiry` to Conversation model
- âœ… Updated IAIFoundryService with `existingThreadId` parameter and `GetThreadInfo()` method
- âœ… AIFoundryService now persists thread info and attempts to resume existing threads
- âœ… ChatApplicationService passes thread ID when resuming, saves new thread info to Cosmos DB
- âœ… Uses Cosmos DB for persistence (no Redis required)

**Problem Solved**:
- Agent threads are now persisted to Cosmos DB
- When user resumes conversation, existing thread is reused (0 extra tokens)
- Thread info saved: ID, creation time, expiry time
- Falls back to new thread if existing thread expired or invalid

```
Resume conversation
       â†“
Check Conversation.AgentThreadId exists?
       â†“
   â”Œâ”€â”€â”€â”´â”€â”€â”€â”
   Yes     No
   â†“       â†“
Try resume    Create new thread
Azure thread  (saves thread info)
   â†“             
Thread valid?    
   â†“             
   Yes â†’ Use it (0 extra tokens!)
   No â†’ Create new thread
```

#### C4.3.5.1: Extend Conversation Model for Thread Persistence âœ…
- [x] Add to src/Models/Conversation.cs:
  ```
  agentThreadId: string?       # Azure AI thread ID for resume
  agentThreadCreatedAt: DateTime?  # Track thread age
  agentThreadExpiry: DateTime?     # When thread likely expires (~24hrs)
  ```
- [x] Cosmos DB automatically saves/retrieves thread ID (no schema changes needed)

#### C4.3.5.2: Implement Thread Resume Logic âœ…
- [x] Added `existingThreadId` parameter to IAIFoundryService methods
- [x] Added `GetThreadInfo(conversationId)` method
- [x] AIFoundryService checks Azure AI for existing thread validity via `GetThreadAsync`
- [x] On successful resume, populates `_conversationThreads` from persisted ID
- [x] Updates Conversation.AgentThreadId when new thread created

#### C4.3.5.3: Implement Message Replay Fallback â³ DEFERRED
- [ ] Add method to IAIFoundryService: `RehydrateThreadAsync(conversationId, messages)`
- [ ] Only needed if thread expiry becomes an issue in practice

#### C4.3.5.4: Integrate with ChatApplicationService âœ…
- [x] `StreamAIResponseAsync()` passes existing thread ID to AIFoundryService
- [x] After AI response, captures thread info via `GetThreadInfo()`
- [x] Saves thread info to Conversation when new thread created
- [x] Thread info persisted to Cosmos DB on conversation update

#### C4.3.5.5: Configuration â³ DEFERRED
- [x] Default thread expiry: 24 hours (hardcoded in AIFoundryService)
- [ ] Add `AIFoundry:ThreadExpiryHours` config option if customization needed

**Edge Cases Handled**:
- âœ… Thread expired: Creates new thread automatically
- âœ… Thread doesn't exist: Creates new thread, saves ID
- âœ… Thread valid: Resumes without token cost
- â³ Very long conversations: Deferred (message replay fallback)

### Task C4.4: Usage Tracking Integration âž¡ï¸ MOVED TO REPORTING SERVICE
Goal: Integrate with the Reporting Service for usage tracking and quota enforcement.

**ðŸ“¦ SEPARATED INTO REPORTING SERVICE**: Usage aggregation, billing, and analytics
are now handled by a separate Reporting Service. See: `instructions/reporting-tasks.txt`

**Architecture**:
```
BlazorChat â”€â”€â–¶ SimpleL7Proxy â”€â”€â–¶ Azure AI
                    â”‚
                    â–¼ (logs tokens)
              App Insights
                    â”‚
                    â–¼ (queries & aggregates)
            Reporting Service â”€â”€â–¶ Cosmos DB (usage)
                    â”‚
                    â–¼ (API)
              BlazorChat (dashboards)
```

**What BlazorChat Needs to Do** (minimal):

#### C4.4.1: Add Correlation Headers âœ… (via proxy config)
- [x] SimpleL7Proxy receives conversationId, userId, orgId from request headers
- [ ] Ensure headers are passed: `x-request-id`, `x-user-id`, `x-org-id`
- [ ] Headers enable linking App Insights telemetry to conversations

#### C4.4.2: Quota Check Before AI Request
- [ ] Create: IReportingServiceClient.cs (HTTP client to Reporting Service)
- [ ] Before sending AI request, call: `CheckQuotaAsync(orgId, userId)`
- [ ] If quota exceeded, return friendly error to user
- [ ] Configuration: `ReportingService:BaseUrl` in appsettings.json

#### C4.4.3: Quota Increment After AI Response
- [ ] After AI response completes, call: `IncrementUsageAsync(orgId, userId, tokens)`
- [ ] Fire-and-forget or queue for reliability
- [ ] Handle failures gracefully (log, don't fail chat)

#### C4.4.4: Usage Dashboard Pages
- [ ] Create: src/Components/Pages/Account/MyUsage.razor
  - Calls Reporting Service API for user's usage
  - Displays token usage, cost estimates
- [ ] Create: src/Components/Pages/Admin/OrgUsageDashboard.razor
  - Calls Reporting Service API for org usage
  - Per-user breakdown, trends

**What Moved to Reporting Service** (see reporting-tasks.txt):
- âŒ Token extraction from SSE streams (handled by SimpleL7Proxy)
- âŒ App Insights query logic
- âŒ Usage aggregation jobs
- âŒ Cost calculation
- âŒ Quota management
- âŒ Alert generation

## PHASE 5: Chat UI Components

### Task C5.1: Add Chat Component Library âœ“
- [x] Research and select Blazor chat UI library (e.g., MudBlazor, FluentUI)
- [x] Add NuGet package for selected library
- [x] Configure library in Program.cs
- [x] Update _Imports.razor with library namespaces

### Task C5.2: Create Chat Components âœ“
- [x] Create component: src/Components/Pages/Chat.razor
  - Display conversation list
  - Display message history
  - Input box for new messages
  - Send button
- [x] Create component: src/Components/Chat/MessageList.razor
- [x] Create component: src/Components/Chat/MessageItem.razor
- [x] Create component: src/Components/Chat/ChatInput.razor
- [x] Create component: src/Components/Chat/ConversationSidebar.razor
 âœ“
- [x] Add NuGet package: Markdig (0.44.0)
- [x] Create component: src/Components/Shared/MarkdownRenderer.razor
- [x] Create styles: src/Components/Shared/MarkdownRenderer.razor.css
- [x] Integrate into Chat.razor for AI message rendering
- [x] Add GitHub-style formatting for code blocks, tables, lists, header
- [ ] Add syntax highlighting for code blocks

### Task C5.4: Organization-Based Theming (Revised) âœ“
- [x] Organization model already includes Custom CSS and HTML snippets (PublicThemeSettings)
- [x] Create service: src/Services/ThemeService.cs
  - GetThemeForOrganization, GetCustomCss, GetDefaultTheme
  - Dynamic MudTheme generation from org colors
- [x] Create component: src/Components/Shared/OrganizationStyleProvider.razor
  - Renders sanitized custom CSS
  - Renders organization header HTML
- [ ] Update MainLayout.razor to use OrganizationStyleProvider
- [x] CSS sanitization via MessageSanitizationService
- [x] Fallback to default theme if no organization settings found
### Task C5.5: Implement Theme Customization
- [ ] Create theme configuration in appsettings.json
- [ ] Create CSS variables for theming in app.css
- [ ] Create service: src/Services/ThemeService.cs
- [ ] Add theme selector in UI
- [ ] Persist user preference to Cosmos DB

## PHASE 6: Real-time Features (SignalR)

### Task C6.1: Add SignalR Infrastructure
- [ ] Add NuGet package: Microsoft.AspNetCore.SignalR (already in .NET)
- [ ] Create hub: src/Hubs/ChatHub.cs
- [ ] Register SignalR in Program.cs
- [ ] Map hub endpoint

### Task C6.2: Implement Streaming Responses
- [ ] Add streaming methods to ChatHub
- [ ] Update AIFoundryService to support streaming
- [ ] Update Chat.razor to receive streaming messages
- [ ] Implement progressive message rendering

### Task C6.3: Add Typing Indicators
- [ ] Add typing indicator methods to ChatHub
- [ ] Create component: src/Components/Chat/TypingIndicator.razor
- [ ] Implement typing event emission from ChatInput
- [ ] Display typing indicators in MessageList

### Task C6.4: Connection State Management
- [ ] Implement reconnection logic in Chat.razor
- [ ] Add connection status indicator component
- [ ] Handle offline scenarios gracefully
- [ ] Show connection state to user

## PHASE 7: Additional Features

### Task C7.1: Implement Caching
- [ ] Add memory cache for conversation metadata
- [ ] Implement cache invalidation strategy
- [ ] Add cache configuration in appsettings.json
- [ ] Register cache in Program.cs

### Task C7.2: Add Search Functionality
- [ ] Create search endpoint/method in ConversationRepository
- [ ] Implement full-text search (consider Azure Cognitive Search)
- [ ] Create search UI component
- [ ] Add search results highlighting

### Task C7.3: Add Export Functionality
- [ ] Create service: src/Services/ExportService.cs
- [ ] Implement export to JSON
- [ ] Implement export to Markdown
- [ ] Add export button to conversation UI
- [ ] Generate downloadable files

### Task C7.4: User Preferences
- [ ] Create UserPreferences repository
- [ ] Create preferences UI page
- [ ] Implement save/load preferences
- [ ] Apply preferences across app (theme, notifications, etc.)

### Task C7.5: File Upload (Optional)
- [ ] Add file upload component
- [ ] Configure Azure Blob Storage
- [ ] Add NuGet package: Azure.Storage.Blobs
- [ ] Implement file upload service
- [ ] Store file references in Cosmos DB

## PHASE 8: Testing & Quality

### Task C8.1: Unit Tests
- [ ] Add test project: BlazorChat.Tests
- [ ] Add NuGet package: xUnit
- [ ] Add NuGet package: Moq
- [ ] Write tests for CosmosDbService
- [ ] Write tests for AIFoundryService
- [ ] Write tests for ConversationRepository
- [ ] Write tests for authorization handlers

### Task C8.2: Integration Tests
- [ ] Add test project: BlazorChat.IntegrationTests
- [ ] Add NuGet package: Microsoft.AspNetCore.Mvc.Testing
- [ ] Write integration tests for API endpoints
- [ ] Test authentication flows
- [ ] Test Cosmos DB integration with emulator

### Task C8.3: Add Swagger/OpenAPI
- [ ] Add NuGet package: Swashbuckle.AspNetCore
- [ ] Configure Swagger in Program.cs
- [ ] Add XML documentation to API methods
- [ ] Configure Swagger UI

## PHASE 9: DevOps & Deployment

### Task C9.1: Docker Support
- [ ] Create Dockerfile in project root
- [ ] Create .dockerignore file
- [ ] Test local Docker build
- [ ] Optimize image size (multi-stage build)

### Task C9.2: Environment Configuration
- [ ] Finalize appsettings.Production.json
- [ ] Document required environment variables
- [ ] Add configuration validation on startup
- [ ] Create configuration README

### Task C9.3: CI/CD Pipeline
- [ ] Create .github/workflows/build.yml (or Azure DevOps YAML)
- [ ] Add build and test steps
- [ ] Add Docker build and push steps
- [ ] Add deployment steps for Azure App Service or ACA
- [ ] Configure environment secrets

### Task C9.4: Azure Resources Setup
- [ ] Create Bicep/Terraform templates in /deploy
- [ ] Define Cosmos DB account and database
- [ ] Define App Service or Azure Container Apps
- [ ] Define Application Insights
- [ ] Define Key Vault
- [ ] Document deployment steps

## PHASE 10: External Identity Providers & Enterprise Authentication
NOTE: Enable social login for consumer scenarios + enterprise SSO for B2B deployments.

### Task C10.1: External Identity Provider Integration (Social Login)
Goal: Allow users to sign in with existing accounts from popular providers.

#### C10.1.1: Add External Provider NuGet Packages
- [ ] Add NuGet package: Microsoft.AspNetCore.Authentication.Google
- [ ] Add NuGet package: Microsoft.AspNetCore.Authentication.Facebook
- [ ] Add NuGet package: Microsoft.AspNetCore.Authentication.Twitter (for X)
- [ ] Add NuGet package: Microsoft.AspNetCore.Authentication.MicrosoftAccount

#### C10.1.2: Configure Provider App Registrations
- [ ] Register app with Google Cloud Console (OAuth 2.0 credentials)
  - Authorized redirect URI: `https://{domain}/signin-google`
- [ ] Register app with Facebook Developer Portal
  - Valid OAuth redirect URI: `https://{domain}/signin-facebook`
- [ ] Register app with X (Twitter) Developer Portal
  - Callback URL: `https://{domain}/signin-twitter`
- [ ] Register app with Microsoft Entra ID (Azure Portal)
  - Redirect URI: `https://{domain}/signin-microsoft`
- [ ] Store all client IDs and secrets in Azure Key Vault

#### C10.1.3: Update Program.cs Authentication Configuration
- [ ] Add authentication services for each provider:
  ```csharp
  .AddGoogle(options => { ... })
  .AddFacebook(options => { ... })
  .AddTwitter(options => { ... })
  .AddMicrosoftAccount(options => { ... })
  ```
- [ ] Configure callback paths for each provider
- [ ] Map external claims to local user properties

#### C10.1.4: Configuration in appsettings.json
- [ ] Add ExternalProviders section:
  ```json
  "ExternalProviders": {
    "Google": { "ClientId": "", "ClientSecret": "" },
    "Facebook": { "AppId": "", "AppSecret": "" },
    "Twitter": { "ConsumerKey": "", "ConsumerSecret": "" },
    "Microsoft": { "ClientId": "", "ClientSecret": "" }
  }
  ```
- [ ] Use Key Vault references for secrets in production

#### C10.1.5: Update Login UI
- [ ] Update src/Components/Account/Pages/Login.razor
  - Add "Sign in with Google" button
  - Add "Sign in with Facebook" button
  - Add "Sign in with X" button
  - Add "Sign in with Microsoft" button
- [ ] Create component: src/Components/Account/Shared/ExternalLoginButtons.razor
- [ ] Style buttons with provider brand colors/icons

#### C10.1.6: Handle External Login Callback
- [ ] Update src/Components/Account/Pages/ExternalLogin.razor
- [ ] Link external account to existing local account (if email matches)
- [ ] Create new local account if first-time external login
- [ ] Handle account linking conflicts gracefully

#### C10.1.7: User Profile Updates
- [ ] Store external provider info in ApplicationUser:
  - ExternalProvider: string (Google, Facebook, X, Microsoft)
  - ExternalProviderId: string
  - ProfilePictureUrl: string (from provider)
- [ ] Allow users to link/unlink multiple providers in Account settings
- [ ] Display provider icon next to user's name

#### C10.1.8: Organization-Level Provider Control (Optional)
- [ ] Allow org admins to enable/disable specific providers per org
- [ ] Add to Organization model:
  - AllowedExternalProviders: string[] (e.g., ["Google", "Microsoft"])
- [ ] Filter login buttons based on org settings

### Task C10.2: Enterprise SSO (Azure AD / Microsoft Entra ID)
Goal: Enable enterprise single sign-on for B2B deployments.

- [ ] Replace ASP.NET Core Identity with Azure AD (Microsoft Entra ID)
- [ ] Add NuGet package: Microsoft.Identity.Web
- [ ] Add NuGet package: Microsoft.Identity.Web.UI
- [ ] Update Program.cs to use AddMicrosoftIdentityWebApp
- [ ] Configure Azure AD settings in appsettings.json:
  - AzureAd:Instance
  - AzureAd:Domain
  - AzureAd:TenantId
  - AzureAd:ClientId
- [ ] Remove Entity Framework Identity dependencies
- [ ] Plan user data migration from SQLite to Azure AD
- [ ] Update authorization policies to work with Azure AD claims
- [ ] Test SSO and multi-factor authentication flows

### Task C10.3: Hybrid Authentication Strategy
Goal: Support both social login (consumers) and enterprise SSO (B2B) simultaneously.

- [ ] Implement authentication mode per organization:
  - "social" - Only external providers (Google, Facebook, X, Microsoft personal)
  - "enterprise" - Only Azure AD tenant (Microsoft work/school)
  - "hybrid" - Both options available
- [ ] Add to Organization model: AuthenticationMode: string
- [ ] Route users to appropriate login flow based on org settings
- [ ] Handle seamless transitions when org upgrades from social to enterprise

## PHASE 11: Compliance & Governance

### Task C11.1: Data Retention
- [ ] Define retention policies
- [ ] Create cleanup service: src/Services/DataRetentionService.cs
- [ ] Implement background job for old data deletion
- [ ] Configure TTL in Cosmos DB (optional)

### Task C11.2: GDPR Compliance
- [ ] Add export user data endpoint
- [ ] Add delete user data endpoint (right to be forgotten)
- [ ] Create privacy policy page
- [ ] Add consent management

### Task C11.3: Audit Logging
- [ ] Create audit log model
- [ ] Log sensitive operations (delete, export, admin actions)
- [ ] Store audit logs in separate Cosmos DB container
- [ ] Create audit log query endpoint (admin only)

## PRIORITY ORDER

### Immediate (MVP - Week 1-2)
1. Task C1.1 - C1.5: Cosmos DB Migration
2. Task C.4.1 - C4.2: Basic AI Foundry Integration
3. Task C.5.1 - C5.2: Basic Chat UI
4. Task C.3.1: Application Insights Setup

### High Priority (Week 3-4)
5. Task C2.4: Key Vault Integration
7. Task C5.3 - C5.4: Markdown & Loading States
8. Task C3.2 - C3.4: Monitoring & Health Checks
9. Task C4.3: Context Management

### Medium Priority (Week 5-6)
10. Task C2.3 - C2.4: CORS & Rate Limiting
11. Task C2.6: Input Validation
12. Task C6.1 - C6.2: SignalR & Streaming
13. Task C5.5: Theme Customization
14. Task C7.1: Caching

### Lower Priority (Week 7-8)
15. Task C6.3 - C6.4: Advanced SignalR Features
16. Task C7.2 - C7.4: Search, Export, Preferences
17. Task C8.1 - C8.2: Testing
18. Task C9.1 - C9.2: Docker & Configuration

### Future Enhancements
19. Task 4.4: AI Usage Tracking
20. Task 7.5: File Upload
21. Task 8.3: Swagger
22. Task 9.3-9.4: CI/CD & IaC

### Post-Demo Enterprise Features
23. Task 10.1: Azure AD Authentication Migration (Enterprise SSO)
24. Task 11.1-11.3: Compliance Features (Data Retention, GDPR, Audit Logging)


