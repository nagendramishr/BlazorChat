# BlazorChat Implementation Tasks

## Current State Analysis
‚úì .NET 10 Blazor web server with Kestrel configured
‚úì ASP.NET Core Identity with Individual authentication
‚úì Entity Framework Core with SQLite database
‚úì Basic authentication components (Account pages)
‚úì Dependency injection configured
‚úì Basic Blazor components structure (Layout, Pages)

================================================================================
## PHASE A: Architecture Improvements (Priority - Do Before New Features)
================================================================================
NOTE: These architectural improvements should be implemented BEFORE continuing with 
Phase 4 incomplete tasks (C4.3.5, C4.4) to ensure clean, scalable implementation.

### SimpleL7Proxy Integration (Assumed Backend)
BlazorChat will use Microsoft's SimpleL7Proxy (https://github.com/microsoft/SimpleL7Proxy)
as the AI gateway. This OSS project provides significant infrastructure benefits:

**What SimpleL7Proxy Provides Out-of-Box**:
- ‚úÖ Token extraction from SSE streams (Prompt_Tokens, Completion_Tokens, Total_Tokens)
- ‚úÖ Application Insights integration with custom dimensions
- ‚úÖ Event Hub streaming for high-volume telemetry
- ‚úÖ Distributed request correlation (MID, ParentId, OperationId)
- ‚úÖ Circuit breaker pattern for backend resilience
- ‚úÖ Multi-backend load balancing and failover
- ‚úÖ Priority queues for user tiering (Gold/Silver)
- ‚úÖ Retry logic with exponential backoff
- ‚úÖ Health check endpoints

**Impact on BlazorChat Tasks**:
- C4.4 (Usage Tracking): SIMPLIFIED - Query App Insights instead of building token extraction
- A2 (MediatR Events): OPTIONAL - Proxy handles telemetry, use events only for app-level concerns
- E2.1 (Distributed Tracing): COVERED - Built-in request correlation
- E3.1 (Quota Management): EASIER - Proxy has priority queues
- E7.4 (Graceful Degradation): SIMPLIFIED - Circuit breaker built-in

### Task A0: SimpleL7Proxy Integration ‚úÖ COMPLETE
Priority: HIGH (Foundation - enables simplified token tracking)
Goal: Route all AI traffic through SimpleL7Proxy gateway via configuration.

**Implementation Summary** (Completed Jan 2026):
- ‚úÖ Added `AIFoundry:ProxyEndpoint` config option in appsettings.json
- ‚úÖ Updated AIFoundryService to use either Endpoint or ProxyEndpoint
- ‚úÖ Error if both are configured (must choose one)
- ‚úÖ Error if neither is configured
- ‚úÖ Logs which endpoint mode is being used (direct vs proxy)

**Usage**:
- For direct connection: Set `AIFoundry:Endpoint`, leave `ProxyEndpoint` empty
- For proxy routing: Set `AIFoundry:ProxyEndpoint`, leave `Endpoint` empty
- Proxy is transparent - no code changes needed for streaming

**Deployment Note**: SimpleL7Proxy deployment/configuration is handled separately.
See: https://github.com/microsoft/SimpleL7Proxy for deployment instructions.

### Current Architecture Issues Identified:
- **Fat Component**: Chat.razor has 500+ lines, handles UI + business logic + coordination
- **No Domain Layer**: Business rules scattered across services and components  
- **Tight Coupling**: Components directly depend on infrastructure services
- **No Event System**: Cross-cutting concerns require manual calls everywhere
- **Stateful Singletons**: AIFoundryService holds in-memory state, doesn't scale
- **No Background Jobs**: Everything is request/response, no async processing

### Task A1: Application Service Layer ‚úÖ COMPLETE
Priority: HIGH (Foundation for all future features)
Goal: Create single entry point for chat operations, extract business logic from Chat.razor.

**Current Problem**:
```
Chat.razor ‚Üí CosmosDbService, AIFoundryService, TelemetryService, 
             OrganizationService, ContextManager (5+ direct dependencies)
```

**Target Architecture**:
```
Chat.razor ‚Üí IChatApplicationService ‚Üí Domain Services ‚Üí Infrastructure
                                    ‚Ü≥ Raises Domain Events
```

#### A1.1: Create Chat Application Service ‚úÖ
- [x] Create interface: src/Services/Application/IChatApplicationService.cs
  ```csharp
  public interface IChatApplicationService
  {
      Task<Conversation> CreateConversationAsync(string userId, string orgId, string? title = null);
      Task<Conversation?> GetConversationAsync(string conversationId, string userId);
      Task<IEnumerable<Conversation>> GetUserConversationsAsync(string userId);
      Task<IEnumerable<Message>> GetMessagesAsync(string conversationId, string userId);
      IAsyncEnumerable<ChatResponseChunk> SendMessageStreamingAsync(string conversationId, string userId, string message, CancellationToken ct);
      Task<bool> DeleteConversationAsync(string conversationId, string userId);
      Task<bool> ResumeConversationAsync(string conversationId, string userId); // Thread rehydration
  }
  ```
- [x] Create implementation: src/Services/Application/ChatApplicationService.cs
- [x] Encapsulate: authorization checks, validation, Cosmos DB calls, AI calls, telemetry
- [x] Register as scoped service in Program.cs

#### A1.2: Refactor Chat.razor to Use Application Service ‚úÖ
- [x] Replace 5+ service injections with single IChatApplicationService (reduced to 2: ChatService + OrganizationService)
- [x] Move all business logic out of Chat.razor
- [x] Keep Chat.razor focused on: UI rendering, user input handling, state display
- [x] Reduced Chat.razor from ~585 lines to ~502 lines (UI-only code)

#### A1.3: Create Organization Application Service (Optional)
- [ ] Create interface: src/Services/Application/IOrganizationApplicationService.cs
- [ ] Consolidate org-related operations from Controller + Services
- [ ] Prepare for Admin UI implementation

### Task A2: Domain Events with MediatR
Priority: MEDIUM (Optional with SimpleL7Proxy - proxy handles AI telemetry)
Goal: Decouple cross-cutting concerns using event-driven architecture.

**With SimpleL7Proxy**: Token tracking telemetry is handled by the proxy.
MediatR is still useful for APP-LEVEL events (conversation created, user actions, audit).
Can be deferred if time-constrained - proxy covers the critical AI observability.

**Current Problem**:
```csharp
// Chat.razor has to remember ALL places to call
await CosmosDbService.SaveMessageAsync(message);
TelemetryService.TrackMessageSent(...);
// TODO: Track usage - easy to forget!
// TODO: Check quota - easy to forget!
// TODO: Audit log - easy to forget!
```

**Target Architecture**:
```csharp
// Publish event once, handlers react independently
await _mediator.Publish(new MessageSentEvent(message, conversationId, userId));
// Handlers: TelemetryHandler, UsageTrackingHandler, QuotaCheckHandler, AuditHandler
```

#### A2.1: Add MediatR Infrastructure
- [ ] Add NuGet package: MediatR
- [ ] Add NuGet package: MediatR.Extensions.Microsoft.DependencyInjection
- [ ] Register MediatR in Program.cs: `builder.Services.AddMediatR(cfg => ...)`
- [ ] Create folder structure: src/Events/, src/Events/Handlers/

#### A2.2: Define Core Domain Events
- [ ] Create event: src/Events/MessageSentEvent.cs
  - Properties: Message, ConversationId, UserId, OrganizationId, Timestamp
- [ ] Create event: src/Events/AIResponseReceivedEvent.cs
  - Properties: ConversationId, ResponseText, TokensUsed, ResponseTimeMs, ModelName
- [ ] Create event: src/Events/ConversationCreatedEvent.cs
- [ ] Create event: src/Events/ConversationDeletedEvent.cs
- [ ] Create event: src/Events/ConversationResumedEvent.cs (for rehydration tracking)

#### A2.3: Migrate Telemetry to Event Handlers
- [ ] Create handler: src/Events/Handlers/TelemetryEventHandler.cs
- [ ] Move TelemetryService.TrackMessageSent() calls to handler
- [ ] Move TelemetryService.TrackAIResponseTime() calls to handler
- [ ] Remove direct TelemetryService calls from Chat.razor/ChatApplicationService

#### A2.4: Prepare for Usage Tracking Integration
- [ ] Create handler stub: src/Events/Handlers/UsageTrackingEventHandler.cs
- [ ] Will be implemented fully in Task C4.4
- [ ] Handler reacts to: MessageSentEvent, AIResponseReceivedEvent, ConversationResumedEvent

### Task A3: Distributed Cache with Redis ‚úÖ PARTIAL (Thread State Complete)
Priority: HIGH (Solves thread persistence AND enables horizontal scaling)
Goal: Externalize session state from in-memory dictionaries.

**Implementation Status** (Completed Jan 2026):
- ‚úÖ Created IThreadStateService interface (src/Services/Cache/IThreadStateService.cs)
- ‚úÖ Created InMemoryThreadStateService (default for dev)
- ‚úÖ Created RedisThreadStateService (production scaling)
- ‚úÖ Created CosmosDbThreadStateService (simple deployments)
- ‚úÖ Added ThreadState:Provider config in appsettings.json
- ‚úÖ Integrated into ChatApplicationService
- ‚è≥ Redis NuGet package optional (commented out until needed)
- ‚è≥ Rate limiting, org cache, user session - not yet implemented

**Current Problem**:
```csharp
// AIFoundryService.cs - state lost on restart, doesn't scale
private readonly ConcurrentDictionary<string, AgentThread> _conversationThreads = new();
```

**Target Architecture**:
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  App Node 1 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ Azure Redis ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ  App Node 2 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ   Cache     ‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

================================================================================
## WHAT TO STORE IN REDIS vs COSMOS DB
================================================================================

### Redis (Fast, Ephemeral, Session-scoped)
Use for: Data that needs sub-millisecond access, can be regenerated, or is short-lived.

| Data | Key Pattern | TTL | Rationale |
|------|-------------|-----|-----------|
| **Thread ID Cache** | `thread:{conversationId}` | 24h | Hot cache for thread resume, source of truth in Cosmos |
| **Rate Limit Counters** | `ratelimit:{userId}:{window}` | 1-60min | Per-user AI request throttling |
| **User Session State** | `session:{userId}` | 30min-2h | Current conversation, UI preferences |
| **Organization Settings Cache** | `org:{orgId}:settings` | 5-15min | Cached org config, refresh on change |
| **Active Typing Indicators** | `typing:{conversationId}` | 5s | Real-time "user is typing" |
| **Feature Flags Cache** | `flags:{orgId}` | 5min | Cached feature toggles |
| **API Response Cache** | `apicache:{hash}` | 1-5min | Cache repeated identical prompts |
| **Distributed Locks** | `lock:{resource}` | 30s | Prevent duplicate operations |
| **Circuit Breaker State** | `circuit:{service}` | Varies | Track service health |

### Cosmos DB (Durable, Queryable, Long-lived)
Use for: Permanent records, audit trails, data that needs querying.

| Data | Container | Rationale |
|------|-----------|-----------|
| Conversations | conversations | Permanent record, queryable by user |
| Messages | messages | Full history, searchable |
| Thread ID (source of truth) | conversations.AgentThreadId | Backup for Redis cache |
| Usage Records | usage | Billing, analytics, compliance |
| Organizations | organizations | Config source of truth |
| User Preferences | userpreferences | Persistent settings |
| Audit Logs | auditlogs | Compliance, debugging |

### NEVER Store in Redis
- [ ] PII without encryption (conversation content, user emails)
- [ ] Billing-critical data (usage records - use Cosmos)
- [ ] Compliance/audit logs (need durability)
- [ ] Large blobs (file attachments - use Blob Storage)

================================================================================

#### A3.1: Add Redis Infrastructure
- [ ] Add NuGet package: Microsoft.Extensions.Caching.StackExchangeRedis
- [ ] Add NuGet package: StackExchange.Redis
- [ ] Add configuration in appsettings.json:
  ```json
  "Redis": {
    "ConnectionString": "<your-redis-connection-string>",
    "InstanceName": "BlazorChat:",
    "DefaultExpiryMinutes": 60,
    "EnableCompression": false
  }
  ```
- [ ] Register IDistributedCache in Program.cs (Redis in prod, InMemory for dev)
- [ ] Create Azure Cache for Redis resource (Basic C0 ~$16/mo for dev)

#### A3.2: Create Cache Service Abstraction
- [ ] Create interface: src/Services/Cache/ICacheService.cs
  ```csharp
  public interface ICacheService
  {
      Task<T?> GetAsync<T>(string key, CancellationToken ct = default);
      Task SetAsync<T>(string key, T value, TimeSpan? expiry = null, CancellationToken ct = default);
      Task RemoveAsync(string key, CancellationToken ct = default);
      Task<bool> ExistsAsync(string key, CancellationToken ct = default);
      Task<T> GetOrSetAsync<T>(string key, Func<Task<T>> factory, TimeSpan? expiry = null, CancellationToken ct = default);
  }
  ```
- [ ] Create implementation: src/Services/Cache/RedisCacheService.cs
- [ ] Create implementation: src/Services/Cache/InMemoryCacheService.cs (for dev)
- [ ] Handle serialization (System.Text.Json)
- [ ] Add logging for cache hits/misses

#### A3.3: Create Thread State Service (Cache Layer)
- [ ] Create interface: src/Services/Cache/IThreadCacheService.cs
  ```csharp
  public interface IThreadCacheService
  {
      Task<ThreadInfo?> GetThreadAsync(string conversationId);
      Task SetThreadAsync(string conversationId, ThreadInfo info);
      Task InvalidateThreadAsync(string conversationId);
  }
  ```
- [ ] Create implementation using ICacheService
- [ ] Key: `thread:{conversationId}`, TTL: 24 hours
- [ ] Fallback: Read from Cosmos DB Conversation.AgentThreadId if cache miss

#### A3.4: Create Rate Limiting Service
- [ ] Create interface: src/Services/Cache/IRateLimitService.cs
  ```csharp
  public interface IRateLimitService
  {
      Task<RateLimitResult> CheckRateLimitAsync(string userId, string limitType);
      Task<int> IncrementAsync(string userId, string limitType, TimeSpan window);
      Task ResetAsync(string userId, string limitType);
  }
  ```
- [ ] Rate limit types:
  - `ai_requests`: 60/minute per user
  - `conversations`: 100/day per user
  - `messages`: 500/hour per user
- [ ] Key: `ratelimit:{userId}:{limitType}:{windowId}`, TTL: window duration

#### A3.5: Create Organization Settings Cache
- [ ] Create interface: src/Services/Cache/IOrgSettingsCacheService.cs
- [ ] Cache org settings on first access
- [ ] Invalidate cache on org settings update
- [ ] Key: `org:{orgId}:settings`, TTL: 10 minutes
- [ ] Reduces Cosmos DB reads for every AI request

#### A3.6: Create User Session State Service
- [ ] Create interface: src/Services/Cache/IUserSessionService.cs
  ```csharp
  public interface IUserSessionService
  {
      Task<UserSessionState?> GetSessionAsync(string userId);
      Task UpdateSessionAsync(string userId, Action<UserSessionState> update);
      Task SetActiveConversationAsync(string userId, string? conversationId);
  }
  ```
- [ ] Store: current conversation, last activity, UI state
- [ ] Key: `session:{userId}`, TTL: 2 hours (sliding)
- [ ] Enables multi-tab consistency

#### A3.7: Refactor AIFoundryService to Use Cache
- [ ] Inject IThreadCacheService instead of ConcurrentDictionary
- [ ] On cache miss: check Cosmos DB, warm cache
- [ ] On new thread: write to cache AND Cosmos DB
- [ ] Remove in-memory `_conversationThreads` dictionary

#### A3.8: Add Cache Metrics and Monitoring
- [ ] Track cache hit/miss ratio
- [ ] Alert on high miss rates (cold cache, Redis issues)
- [ ] Log cache operations at Debug level
- [ ] Add health check for Redis connectivity

### Task A4: Background Job Infrastructure
Priority: MEDIUM (Needed for usage aggregation, webhooks, cleanup)
Goal: Enable async processing outside request/response cycle.

#### A4.1: Add Background Job Framework
- [ ] Option A: Azure Service Bus + Worker (production-ready)
- [ ] Option B: Hangfire (simpler, built-in dashboard)
- [ ] Option C: .NET BackgroundService (simplest, single-instance only)
- [ ] Recommended: Start with BackgroundService, migrate to Service Bus later

#### A4.2: Create Job Infrastructure
- [ ] Create folder: src/Jobs/
- [ ] Create base class: src/Jobs/BaseBackgroundJob.cs
- [ ] Create job queue interface: src/Services/IJobQueue.cs

#### A4.3: Define Initial Jobs
- [ ] Job: DailyUsageAggregationJob - Rollup conversation usage to daily summaries
- [ ] Job: DataRetentionCleanupJob - Delete old soft-deleted records
- [ ] Job: ThreadExpirationCleanupJob - Clean up expired thread references
- [ ] Job: WebhookDeliveryJob - Retry failed webhook deliveries (future)

### Task A5: Repository Pattern Refactoring
Priority: LOW (Optional but improves testability)
Goal: Separate data access from business logic in CosmosDbService.

#### A5.1: Extract Repository Interfaces
- [ ] Create interface: src/Repositories/IConversationRepository.cs
- [ ] Create interface: src/Repositories/IMessageRepository.cs
- [ ] Create interface: src/Repositories/IOrganizationRepository.cs
- [ ] Create interface: src/Repositories/IUsageRepository.cs

#### A5.2: Implement Repositories
- [ ] Create: src/Repositories/CosmosConversationRepository.cs
- [ ] Create: src/Repositories/CosmosMessageRepository.cs
- [ ] Move pure CRUD operations from CosmosDbService to repositories
- [ ] Keep CosmosDbService as facade or deprecate

#### A5.3: Update Service Registrations
- [ ] Register repositories as scoped services
- [ ] Update ChatApplicationService to use repositories
- [ ] Create mock repositories for unit testing

================================================================================
## Architecture Implementation Order
================================================================================

**Recommended Sequence**:
```
Week 1: A1 (Application Service) + A2 (MediatR)
        ‚îî‚îÄ‚îÄ Chat.razor becomes thin, events enable clean tracking

Week 2: A3 (Redis) 
        ‚îî‚îÄ‚îÄ Solves thread persistence, enables scaling
        ‚îî‚îÄ‚îÄ C4.3.5 becomes trivial to implement

Week 3: C4.3.5 (Thread Persistence) + C4.4 (Usage Tracking)
        ‚îî‚îÄ‚îÄ Built on solid architectural foundation
        ‚îî‚îÄ‚îÄ Usage tracking uses event handlers from A2

Week 4: A4 (Background Jobs) + Usage aggregation
        ‚îî‚îÄ‚îÄ Daily rollups, cleanup jobs

Future: A5 (Repository Pattern) - when adding unit tests
```

================================================================================
## PHASE 1: Data Layer Migration (Cosmos DB)

### Task C1.1: Install Cosmos DB Dependencies ‚úì
- [x] Add NuGet package: Microsoft.Azure.Cosmos (latest)
- [x] Add NuGet package: Azure.Identity (for DefaultAzureCredential)
- [ ] Remove/phase out: Microsoft.EntityFrameworkCore.Sqlite
- [x] Update src.csproj file

### Task C1.2: Create Cosmos DB Models and Schema ‚úì
- [x] Create folder: src/Models
- [x] Create model: src/Models/Conversation.cs
  - Properties: Id, UserId, Title, CreatedAt, UpdatedAt, PartitionKey (UserId)
- [x] Create model: src/Models/Message.cs
  - Properties: Id, ConversationId, UserId, Content, Role (User/Assistant), Timestamp, Metadata
- [x] Create model: src/Models/UserPreferences.cs
  - Properties: UserId, Theme, NotificationSettings, etc.

### Task C1.3: Create Cosmos DB Service Layer ‚úì
- [x] Create interface: src/Services/ICosmosDbService.cs
- [x] Create service: src/Services/CosmosDbService.cs
  - Implement singleton pattern with CosmosClient
  - Use DefaultAzureCredential for authentication
  - Implement methods: GetConversationsAsync, GetMessagesAsync, SaveMessageAsync, etc.
  - Enable diagnostic logging
- [x] Create folder: src/Services
- [x] Register service as singleton in Program.cs

### Task C1.4: Update Configuration (Partial) ‚ö°
- [x] Add Cosmos DB settings to appsettings.json:
  - CosmosDb:Endpoint
  - CosmosDb:DatabaseName
  - CosmosDb:ConversationsContainerName
  - CosmosDb:PreferencesContainerName
- [x] Add environment-specific configs in appsettings.Development.json
- [ ] Remove SQLite connection string

### Task C1.5: Create Cosmos DB Repository Pattern
- [x] ALTERNATIVE: Integrated CosmosDbService directly into Chat UI (simpler approach)
- [x] Implemented conversation loading from Cosmos DB
- [x] Implemented message loading with proper partition keys
- [x] Implemented conversation creation and persistence
- [x] Implemented message persistence (user and assistant)
- [x] Added error handling and user notifications
- [x] Added conversation auto-titling from first message
NOTE: Skipped separate repository layer - using service directly is sufficient for this app

## PHASE 2: Security Updates
NOTE: Current ASP.NET Core Identity with SQLite is sufficient for demo. Azure AD migration is planned for post-demo (see Phase 10).

### Task C2.1: Implement Authorization Policies (Current Identity) ‚úì
- [x] Create policy: UserCanAccessOwnConversations
- [x] Create authorization handler: src/Authorization/ConversationAuthorizationHandler.cs
- [x] Register policies in Program.cs
- [x] Apply [Authorize] attributes to endpoints/components

### Task C2.2: Configure CORS ‚úì
- [x] Add CORS policy in Program.cs (AllowConfiguredOrigins policy)
- [x] Configure allowed origins in appsettings.json (Cors:AllowedOrigins array)
- [x] Apply CORS middleware (UseCors)

### Task C2.3: Implement Rate Limiting ‚úì
- [x] Add NuGet package: Microsoft.AspNetCore.RateLimiting (built-in to ASP.NET Core)
- [x] Configure rate limiting policies in Program.cs (GlobalLimit: 100/min, AILimit: 20/min)
- [x] Apply rate limiting middleware (UseRateLimiter)
- [x] Configure limits in appsettings.json (RateLimiting section)

### Task C2.4: Add Azure Key Vault Integration ‚úì
- [x] Add NuGet package: Azure.Extensions.AspNetCore.Configuration.Secrets
- [x] Add NuGet package: Azure.Security.KeyVault.Secrets
- [x] Update Program.cs to add Key Vault configuration provider
- [x] Configure Key Vault URL in appsettings.json
- [x] Move sensitive settings (AI Foundry keys) to Key Vault (optional configuration)

### Task C2.5: Input Validation & Sanitization ‚úì
- [x] Add NuGet package: System.ComponentModel.Annotations (built-in)
- [x] Create validation models: src/Models/ValidationModels.cs
  - ChatMessageInput, ConversationInput, OrganizationInput
- [x] Implement message sanitization service: src/Services/MessageSanitizationService.cs
  - SanitizeMessage, SanitizeSlug, SanitizeCss, ContainsPromptInjection
- [x] Add validation attributes to input models
- [x] Register sanitization service in Program.cs (singleton)

## PHASE 2.5: Multi-Organization Architecture (New)
Goal: Support multiple organizations with isolated configuration and branding sharing the same db instance.

### Task C2.5.1: Multi-Organization Database Schema ‚úì
- [x] Create model: src/Models/Organization.cs
  - Properties: Id, Name, Slug (Index), PublicThemeSettings, PrivateAIConfig
  - Look & Feel: CustomCss (string), HeaderHtml (string), FooterHtml (string)
  - NOTE: Split model into "OrganizationPublicDTO" (Theme/Branding) for UI and "OrganizationSecrets" for Server to prevent leaking AI keys via public URL probing.
- [x] Update model: src/Data/ApplicationUser.cs
  - Add property: OrganizationId

### Task C2.5.2: Organization Resolution Strategy ‚úì
- [x] Implement Organization Service: src/Services/OrganizationService.cs
- [x] Update routing to support `/org/{slug}/...`
- [x] Create Organization Resolver Component: src/Components/Shared/OrganizationResolver.razor
- [x] Validate Slug Uniqueness on creation.

### Task C2.5.3: Organization Management API Service (New) ‚úì
- [x] Create interface: src/Services/IOrganizationAdminService.cs
- [x] Implement service: src/Services/OrganizationAdminService.cs
  - Methods: CreateOrganizationAsync, UpdateOrganizationAsync, DisableOrganizationAsync, ListOrganizationsAsync
- [x] Create API Endpoints or Admin Page to manage organizations.
  - Implemented `src/Controllers/OrganizationController.cs`
- [ ] Create Admin Policy: Require "GlobalAdmin" role.
- [ ] Create Admin UI Pages (optional for now, API first).

### Task C2.5.4: Infrastructure Automation ‚úì
- [x] Create Azure CLI setup script: scripts/init-azure-resources.ps1 (and .sh)
- [x] Verify script creates all containers including `organizations`.
- [x] Update CosmosDbService to manage Organizations container logic.

### Task C2.5.5: UI Configuration Updates ‚úì
- [x] Update MainLayout to support dynamic branding colors (MudBlazor).
- [x] Add Organization Awareness to NavMenu.
- [x] Fix MudBlazor provider duplication issues in interactive rendering.
- [ ] Create page: src/Components/Pages/Admin/OrganizationList.razor
- [ ] Implement basic CRUD for Organizations

## PHASE 3: Application Insights & Monitoring

### Task C3.1: Add Application Insights ‚úì
- [x] Add NuGet package: Microsoft.ApplicationInsights.AspNetCore
- [x] Add Application Insights to Program.cs
- [x] Configure instrumentation key in appsettings.json
- [x] Enable connection string in appsettings (use Key Vault)

### Task C3.2: Add Custom Telemetry ‚úì
- [x] Create service: src/Services/TelemetryService.cs
- [x] Add custom events: MessageSent, MessageReceived, AIResponseTime
- [x] Add custom metrics: ConversationLength, TokenUsage, ResponseLatency
- [x] Track exceptions with custom properties
- [x] Register service in Program.cs

### Task C3.3: Add Health Checks ‚úì
- [x] Add NuGet package: Microsoft.Extensions.Diagnostics.HealthChecks (built-in to ASP.NET Core)
- [x] Create health check: src/HealthChecks/CosmosDbHealthCheck.cs
- [x] Create health check: src/HealthChecks/AIFoundryHealthCheck.cs
- [x] Add health check endpoints in Program.cs:
  - /liveness (basic app alive check)
  - /startup (dependencies initialized check)
  - /readiness (ready to accept traffic check)
- [ ] Configure health check UI (optional)

### Task C3.4: Cosmos DB Diagnostic Logging ‚úì
- [x] Enable Cosmos DB diagnostics in CosmosDbService
- [x] Log diagnostic strings for slow queries (> threshold)
- [x] Log diagnostic strings on errors
- [ ] Add custom log filtering in appsettings.json

## PHASE 4: AI Foundry Integration

### Task C4.1: Add AI Foundry SDK ‚úì
- [x] Add NuGet package: Azure.AI.Projects
- [x] Add NuGet package: Microsoft.Agents.AI.AzureAI
- [x] Add configuration in appsettings.json:
  - AIFoundry:Endpoint
  - AIFoundry:ModelDeployment
  - AIFoundry:AgentName
  - AIFoundry:AgentInstructions
- [ ] Store API keys in Key Vault (user will provide endpoint details)

### Task C4.2: Create AI Service Layer ‚úì
- [x] Create interface: src/Services/IAIFoundryService.cs
- [x] Create service: src/Services/AIFoundryService.cs
  - Implement agent communication with Microsoft Agent Framework
  - Implement streaming response support
  - Implement error handling and thread management
  - Implement conversation context via AgentThread
  - Use DefaultAzureCredential
- [x] Register service in Program.cs
- [x] Integrate with Chat.razor for streaming responses

### Task C4.5: Multi-Organization AI Configuration (New) ‚úì
- [x] Create AIFoundryServiceFactory: src/Services/AIFoundryServiceFactory.cs
  - Factory pattern for creating org-specific AI service instances
  - OrganizationAIConfiguration wrapper for dynamic config
- [x] Implement dynamic agent configuration resolution based on current Organization
- [x] AIFoundryService accepts IConfiguration (works with org-specific config)
- [x] Register AIFoundryServiceFactory in Program.cs
- [ ] Test with multiple agent endpoints

### Task C4.3: Create Conversation Context Manager ‚úì
- [x] Create service: src/Services/ConversationContextManager.cs
- [x] Implement token counting
- [x] Implement context trimming strategy
- [x] Implement conversation summarization stub
- [x] Register service in Program.cs
- [x] Integrate into Chat.razor for token limit checking

### Task C4.3.5: Thread Persistence & Rehydration on Conversation Resume ‚úÖ COMPLETE
Goal: Restore AI agent context when user resumes a previous conversation without double-billing tokens.

**Implementation Summary** (Completed Jan 2026):
- ‚úÖ Added `AgentThreadId`, `AgentThreadCreatedAt`, `AgentThreadExpiry` to Conversation model
- ‚úÖ Updated IAIFoundryService with `existingThreadId` parameter and `GetThreadInfo()` method
- ‚úÖ AIFoundryService now persists thread info and attempts to resume existing threads
- ‚úÖ ChatApplicationService passes thread ID when resuming, saves new thread info to Cosmos DB
- ‚úÖ Uses Cosmos DB for persistence (no Redis required)

**Problem Solved**:
- Agent threads are now persisted to Cosmos DB
- When user resumes conversation, existing thread is reused (0 extra tokens)
- Thread info saved: ID, creation time, expiry time
- Falls back to new thread if existing thread expired or invalid

```
Resume conversation
       ‚Üì
Check Conversation.AgentThreadId exists?
       ‚Üì
   ‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îê
   Yes     No
   ‚Üì       ‚Üì
Try resume    Create new thread
Azure thread  (saves thread info)
   ‚Üì             
Thread valid?    
   ‚Üì             
   Yes ‚Üí Use it (0 extra tokens!)
   No ‚Üí Create new thread
```

#### C4.3.5.1: Extend Conversation Model for Thread Persistence ‚úÖ
- [x] Add to src/Models/Conversation.cs:
  ```
  agentThreadId: string?       # Azure AI thread ID for resume
  agentThreadCreatedAt: DateTime?  # Track thread age
  agentThreadExpiry: DateTime?     # When thread likely expires (~24hrs)
  ```
- [x] Cosmos DB automatically saves/retrieves thread ID (no schema changes needed)

#### C4.3.5.2: Implement Thread Resume Logic ‚úÖ
- [x] Added `existingThreadId` parameter to IAIFoundryService methods
- [x] Added `GetThreadInfo(conversationId)` method
- [x] AIFoundryService checks Azure AI for existing thread validity via `GetThreadAsync`
- [x] On successful resume, populates `_conversationThreads` from persisted ID
- [x] Updates Conversation.AgentThreadId when new thread created

#### C4.3.5.3: Implement Message Replay Fallback ‚è≥ DEFERRED
- [ ] Add method to IAIFoundryService: `RehydrateThreadAsync(conversationId, messages)`
- [ ] Only needed if thread expiry becomes an issue in practice

#### C4.3.5.4: Integrate with ChatApplicationService ‚úÖ
- [x] `StreamAIResponseAsync()` passes existing thread ID to AIFoundryService
- [x] After AI response, captures thread info via `GetThreadInfo()`
- [x] Saves thread info to Conversation when new thread created
- [x] Thread info persisted to Cosmos DB on conversation update

#### C4.3.5.5: Configuration ‚è≥ DEFERRED
- [x] Default thread expiry: 24 hours (hardcoded in AIFoundryService)
- [ ] Add `AIFoundry:ThreadExpiryHours` config option if customization needed

**Edge Cases Handled**:
- ‚úÖ Thread expired: Creates new thread automatically
- ‚úÖ Thread doesn't exist: Creates new thread, saves ID
- ‚úÖ Thread valid: Resumes without token cost
- ‚è≥ Very long conversations: Deferred (message replay fallback)

### Task C4.4: Usage Tracking Integration ‚û°Ô∏è MOVED TO REPORTING SERVICE
Goal: Integrate with the Reporting Service for usage tracking and quota enforcement.

**üì¶ SEPARATED INTO REPORTING SERVICE**: Usage aggregation, billing, and analytics
are now handled by a separate Reporting Service. See: `instructions/reporting-tasks.txt`

**Architecture**:
```
BlazorChat ‚îÄ‚îÄ‚ñ∂ SimpleL7Proxy ‚îÄ‚îÄ‚ñ∂ Azure AI
                    ‚îÇ
                    ‚ñº (logs tokens)
              App Insights
                    ‚îÇ
                    ‚ñº (queries & aggregates)
            Reporting Service ‚îÄ‚îÄ‚ñ∂ Cosmos DB (usage)
                    ‚îÇ
                    ‚ñº (API)
              BlazorChat (dashboards)
```

**What BlazorChat Needs to Do** (minimal):

#### C4.4.1: Add Correlation Headers ‚úÖ (via proxy config)
- [x] SimpleL7Proxy receives conversationId, userId, orgId from request headers
- [ ] Ensure headers are passed: `x-request-id`, `x-user-id`, `x-org-id`
- [ ] Headers enable linking App Insights telemetry to conversations

#### C4.4.2: Quota Check Before AI Request
- [ ] Create: IReportingServiceClient.cs (HTTP client to Reporting Service)
- [ ] Before sending AI request, call: `CheckQuotaAsync(orgId, userId)`
- [ ] If quota exceeded, return friendly error to user
- [ ] Configuration: `ReportingService:BaseUrl` in appsettings.json

#### C4.4.3: Quota Increment After AI Response
- [ ] After AI response completes, call: `IncrementUsageAsync(orgId, userId, tokens)`
- [ ] Fire-and-forget or queue for reliability
- [ ] Handle failures gracefully (log, don't fail chat)

#### C4.4.4: Usage Dashboard Pages
- [ ] Create: src/Components/Pages/Account/MyUsage.razor
  - Calls Reporting Service API for user's usage
  - Displays token usage, cost estimates
- [ ] Create: src/Components/Pages/Admin/OrgUsageDashboard.razor
  - Calls Reporting Service API for org usage
  - Per-user breakdown, trends

**What Moved to Reporting Service** (see reporting-tasks.txt):
- ‚ùå Token extraction from SSE streams (handled by SimpleL7Proxy)
- ‚ùå App Insights query logic
- ‚ùå Usage aggregation jobs
- ‚ùå Cost calculation
- ‚ùå Quota management
- ‚ùå Alert generation

## PHASE 5: Chat UI Components

### Task C5.1: Add Chat Component Library ‚úì
- [x] Research and select Blazor chat UI library (e.g., MudBlazor, FluentUI)
- [x] Add NuGet package for selected library
- [x] Configure library in Program.cs
- [x] Update _Imports.razor with library namespaces

### Task C5.2: Create Chat Components ‚úì
- [x] Create component: src/Components/Pages/Chat.razor
  - Display conversation list
  - Display message history
  - Input box for new messages
  - Send button
- [x] Create component: src/Components/Chat/MessageList.razor
- [x] Create component: src/Components/Chat/MessageItem.razor
- [x] Create component: src/Components/Chat/ChatInput.razor
- [x] Create component: src/Components/Chat/ConversationSidebar.razor
 ‚úì
- [x] Add NuGet package: Markdig (0.44.0)
- [x] Create component: src/Components/Shared/MarkdownRenderer.razor
- [x] Create styles: src/Components/Shared/MarkdownRenderer.razor.css
- [x] Integrate into Chat.razor for AI message rendering
- [x] Add GitHub-style formatting for code blocks, tables, lists, header
- [ ] Add syntax highlighting for code blocks

### Task C5.4: Organization-Based Theming (Revised) ‚úì
- [x] Organization model already includes Custom CSS and HTML snippets (PublicThemeSettings)
- [x] Create service: src/Services/ThemeService.cs
  - GetThemeForOrganization, GetCustomCss, GetDefaultTheme
  - Dynamic MudTheme generation from org colors
- [x] Create component: src/Components/Shared/OrganizationStyleProvider.razor
  - Renders sanitized custom CSS
  - Renders organization header HTML
- [ ] Update MainLayout.razor to use OrganizationStyleProvider
- [x] CSS sanitization via MessageSanitizationService
- [x] Fallback to default theme if no organization settings found
### Task C5.5: Implement Theme Customization
- [ ] Create theme configuration in appsettings.json
- [ ] Create CSS variables for theming in app.css
- [ ] Create service: src/Services/ThemeService.cs
- [ ] Add theme selector in UI
- [ ] Persist user preference to Cosmos DB

## PHASE 6: Real-time Features (SignalR)

### Task C6.1: Add SignalR Infrastructure
- [ ] Add NuGet package: Microsoft.AspNetCore.SignalR (already in .NET)
- [ ] Create hub: src/Hubs/ChatHub.cs
- [ ] Register SignalR in Program.cs
- [ ] Map hub endpoint

### Task C6.2: Implement Streaming Responses
- [ ] Add streaming methods to ChatHub
- [ ] Update AIFoundryService to support streaming
- [ ] Update Chat.razor to receive streaming messages
- [ ] Implement progressive message rendering

### Task C6.3: Add Typing Indicators
- [ ] Add typing indicator methods to ChatHub
- [ ] Create component: src/Components/Chat/TypingIndicator.razor
- [ ] Implement typing event emission from ChatInput
- [ ] Display typing indicators in MessageList

### Task C6.4: Connection State Management
- [ ] Implement reconnection logic in Chat.razor
- [ ] Add connection status indicator component
- [ ] Handle offline scenarios gracefully
- [ ] Show connection state to user

## PHASE 7: Additional Features

### Task C7.1: Implement Caching
- [ ] Add memory cache for conversation metadata
- [ ] Implement cache invalidation strategy
- [ ] Add cache configuration in appsettings.json
- [ ] Register cache in Program.cs

### Task C7.2: Add Search Functionality
- [ ] Create search endpoint/method in ConversationRepository
- [ ] Implement full-text search (consider Azure Cognitive Search)
- [ ] Create search UI component
- [ ] Add search results highlighting

### Task C7.3: Add Export Functionality
- [ ] Create service: src/Services/ExportService.cs
- [ ] Implement export to JSON
- [ ] Implement export to Markdown
- [ ] Add export button to conversation UI
- [ ] Generate downloadable files

### Task C7.4: User Preferences
- [ ] Create UserPreferences repository
- [ ] Create preferences UI page
- [ ] Implement save/load preferences
- [ ] Apply preferences across app (theme, notifications, etc.)

### Task C7.5: File Upload (Optional)
- [ ] Add file upload component
- [ ] Configure Azure Blob Storage
- [ ] Add NuGet package: Azure.Storage.Blobs
- [ ] Implement file upload service
- [ ] Store file references in Cosmos DB

## PHASE 8: Testing & Quality

### Task C8.1: Unit Tests
- [ ] Add test project: BlazorChat.Tests
- [ ] Add NuGet package: xUnit
- [ ] Add NuGet package: Moq
- [ ] Write tests for CosmosDbService
- [ ] Write tests for AIFoundryService
- [ ] Write tests for ConversationRepository
- [ ] Write tests for authorization handlers

### Task C8.2: Integration Tests
- [ ] Add test project: BlazorChat.IntegrationTests
- [ ] Add NuGet package: Microsoft.AspNetCore.Mvc.Testing
- [ ] Write integration tests for API endpoints
- [ ] Test authentication flows
- [ ] Test Cosmos DB integration with emulator

### Task C8.3: Add Swagger/OpenAPI
- [ ] Add NuGet package: Swashbuckle.AspNetCore
- [ ] Configure Swagger in Program.cs
- [ ] Add XML documentation to API methods
- [ ] Configure Swagger UI

## PHASE 9: DevOps & Deployment

### Task C9.1: Docker Support
- [ ] Create Dockerfile in project root
- [ ] Create .dockerignore file
- [ ] Test local Docker build
- [ ] Optimize image size (multi-stage build)

### Task C9.2: Environment Configuration
- [ ] Finalize appsettings.Production.json
- [ ] Document required environment variables
- [ ] Add configuration validation on startup
- [ ] Create configuration README

### Task C9.3: CI/CD Pipeline
- [ ] Create .github/workflows/build.yml (or Azure DevOps YAML)
- [ ] Add build and test steps
- [ ] Add Docker build and push steps
- [ ] Add deployment steps for Azure App Service or ACA
- [ ] Configure environment secrets

### Task C9.4: Azure Resources Setup
- [ ] Create Bicep/Terraform templates in /deploy
- [ ] Define Cosmos DB account and database
- [ ] Define App Service or Azure Container Apps
- [ ] Define Application Insights
- [ ] Define Key Vault
- [ ] Document deployment steps

## PHASE 10: External Identity Providers & Enterprise Authentication
NOTE: Enable social login for consumer scenarios + enterprise SSO for B2B deployments.

### Task C10.1: External Identity Provider Integration (Social Login)
Goal: Allow users to sign in with existing accounts from popular providers.

#### C10.1.1: Add External Provider NuGet Packages
- [ ] Add NuGet package: Microsoft.AspNetCore.Authentication.Google
- [ ] Add NuGet package: Microsoft.AspNetCore.Authentication.Facebook
- [ ] Add NuGet package: Microsoft.AspNetCore.Authentication.Twitter (for X)
- [ ] Add NuGet package: Microsoft.AspNetCore.Authentication.MicrosoftAccount

#### C10.1.2: Configure Provider App Registrations
- [ ] Register app with Google Cloud Console (OAuth 2.0 credentials)
  - Authorized redirect URI: `https://{domain}/signin-google`
- [ ] Register app with Facebook Developer Portal
  - Valid OAuth redirect URI: `https://{domain}/signin-facebook`
- [ ] Register app with X (Twitter) Developer Portal
  - Callback URL: `https://{domain}/signin-twitter`
- [ ] Register app with Microsoft Entra ID (Azure Portal)
  - Redirect URI: `https://{domain}/signin-microsoft`
- [ ] Store all client IDs and secrets in Azure Key Vault

#### C10.1.3: Update Program.cs Authentication Configuration
- [ ] Add authentication services for each provider:
  ```csharp
  .AddGoogle(options => { ... })
  .AddFacebook(options => { ... })
  .AddTwitter(options => { ... })
  .AddMicrosoftAccount(options => { ... })
  ```
- [ ] Configure callback paths for each provider
- [ ] Map external claims to local user properties

#### C10.1.4: Configuration in appsettings.json
- [ ] Add ExternalProviders section:
  ```json
  "ExternalProviders": {
    "Google": { "ClientId": "", "ClientSecret": "" },
    "Facebook": { "AppId": "", "AppSecret": "" },
    "Twitter": { "ConsumerKey": "", "ConsumerSecret": "" },
    "Microsoft": { "ClientId": "", "ClientSecret": "" }
  }
  ```
- [ ] Use Key Vault references for secrets in production

#### C10.1.5: Update Login UI
- [ ] Update src/Components/Account/Pages/Login.razor
  - Add "Sign in with Google" button
  - Add "Sign in with Facebook" button
  - Add "Sign in with X" button
  - Add "Sign in with Microsoft" button
- [ ] Create component: src/Components/Account/Shared/ExternalLoginButtons.razor
- [ ] Style buttons with provider brand colors/icons

#### C10.1.6: Handle External Login Callback
- [ ] Update src/Components/Account/Pages/ExternalLogin.razor
- [ ] Link external account to existing local account (if email matches)
- [ ] Create new local account if first-time external login
- [ ] Handle account linking conflicts gracefully

#### C10.1.7: User Profile Updates
- [ ] Store external provider info in ApplicationUser:
  - ExternalProvider: string (Google, Facebook, X, Microsoft)
  - ExternalProviderId: string
  - ProfilePictureUrl: string (from provider)
- [ ] Allow users to link/unlink multiple providers in Account settings
- [ ] Display provider icon next to user's name

#### C10.1.8: Organization-Level Provider Control (Optional)
- [ ] Allow org admins to enable/disable specific providers per org
- [ ] Add to Organization model:
  - AllowedExternalProviders: string[] (e.g., ["Google", "Microsoft"])
- [ ] Filter login buttons based on org settings

### Task C10.2: Enterprise SSO (Azure AD / Microsoft Entra ID)
Goal: Enable enterprise single sign-on for B2B deployments.

- [ ] Replace ASP.NET Core Identity with Azure AD (Microsoft Entra ID)
- [ ] Add NuGet package: Microsoft.Identity.Web
- [ ] Add NuGet package: Microsoft.Identity.Web.UI
- [ ] Update Program.cs to use AddMicrosoftIdentityWebApp
- [ ] Configure Azure AD settings in appsettings.json:
  - AzureAd:Instance
  - AzureAd:Domain
  - AzureAd:TenantId
  - AzureAd:ClientId
- [ ] Remove Entity Framework Identity dependencies
- [ ] Plan user data migration from SQLite to Azure AD
- [ ] Update authorization policies to work with Azure AD claims
- [ ] Test SSO and multi-factor authentication flows

### Task C10.3: Hybrid Authentication Strategy
Goal: Support both social login (consumers) and enterprise SSO (B2B) simultaneously.

- [ ] Implement authentication mode per organization:
  - "social" - Only external providers (Google, Facebook, X, Microsoft personal)
  - "enterprise" - Only Azure AD tenant (Microsoft work/school)
  - "hybrid" - Both options available
- [ ] Add to Organization model: AuthenticationMode: string
- [ ] Route users to appropriate login flow based on org settings
- [ ] Handle seamless transitions when org upgrades from social to enterprise

## PHASE 11: Compliance & Governance

### Task C11.1: Data Retention
- [ ] Define retention policies
- [ ] Create cleanup service: src/Services/DataRetentionService.cs
- [ ] Implement background job for old data deletion
- [ ] Configure TTL in Cosmos DB (optional)

### Task C11.2: GDPR Compliance
- [ ] Add export user data endpoint
- [ ] Add delete user data endpoint (right to be forgotten)
- [ ] Create privacy policy page
- [ ] Add consent management

### Task C11.3: Audit Logging
- [ ] Create audit log model
- [ ] Log sensitive operations (delete, export, admin actions)
- [ ] Store audit logs in separate Cosmos DB container
- [ ] Create audit log query endpoint (admin only)

## PRIORITY ORDER

### Immediate (MVP - Week 1-2)
1. Task C1.1 - C1.5: Cosmos DB Migration
2. Task C.4.1 - C4.2: Basic AI Foundry Integration
3. Task C.5.1 - C5.2: Basic Chat UI
4. Task C.3.1: Application Insights Setup

### High Priority (Week 3-4)
5. Task C2.4: Key Vault Integration
7. Task C5.3 - C5.4: Markdown & Loading States
8. Task C3.2 - C3.4: Monitoring & Health Checks
9. Task C4.3: Context Management

### Medium Priority (Week 5-6)
10. Task C2.3 - C2.4: CORS & Rate Limiting
11. Task C2.6: Input Validation
12. Task C6.1 - C6.2: SignalR & Streaming
13. Task C5.5: Theme Customization
14. Task C7.1: Caching

### Lower Priority (Week 7-8)
15. Task C6.3 - C6.4: Advanced SignalR Features
16. Task C7.2 - C7.4: Search, Export, Preferences
17. Task C8.1 - C8.2: Testing
18. Task C9.1 - C9.2: Docker & Configuration

### Future Enhancements
19. Task 4.4: AI Usage Tracking
20. Task 7.5: File Upload
21. Task 8.3: Swagger
22. Task 9.3-9.4: CI/CD & IaC

### Post-Demo Enterprise Features
23. Task 10.1: Azure AD Authentication Migration (Enterprise SSO)
24. Task 11.1-11.3: Compliance Features (Data Retention, GDPR, Audit Logging)


